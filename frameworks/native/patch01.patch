diff --git a/libs/binder/IPCThreadState.cpp b/libs/binder/IPCThreadState.cpp
index 8960ff9..967215c 100644
--- a/libs/binder/IPCThreadState.cpp
+++ b/libs/binder/IPCThreadState.cpp
@@ -366,6 +366,10 @@ extern "C" int _ZN7android14IPCThreadState13getCallingPidEv(IPCThreadState *stat
     return state->getCallingPid();
 }
 
+extern "C" int _ZN7android14IPCThreadState13getCallingUidEv(IPCThreadState *state) {
+    return state->getCallingUid();
+}
+
 int IPCThreadState::getCallingPid() const
 {
     return mCallingPid;
diff --git a/libs/binder/ProcessState.cpp b/libs/binder/ProcessState.cpp
index c1e49bc..ef2beda 100644
--- a/libs/binder/ProcessState.cpp
+++ b/libs/binder/ProcessState.cpp
@@ -345,7 +345,7 @@ static int open_driver()
     int fd = open("/dev/binder", O_RDWR);
     if (fd >= 0) {
         fcntl(fd, F_SETFD, FD_CLOEXEC);
-        int vers;
+        int vers = 0;
         status_t result = ioctl(fd, BINDER_VERSION, &vers);
         if (result == -1) {
             ALOGE("Binder ioctl to obtain version failed: %s", strerror(errno));
diff --git a/libs/gui/BufferQueue.cpp b/libs/gui/BufferQueue.cpp
index 5f2c370..f6397e5 100644
--- a/libs/gui/BufferQueue.cpp
+++ b/libs/gui/BufferQueue.cpp
@@ -33,6 +33,8 @@
 #include <utils/Trace.h>
 #include <utils/CallStack.h>
 
+static const nsecs_t DEQUEUE_TIMEOUT_VALUE = seconds(3);
+
 // Macros for including the BufferQueue name in log messages
 #define ST_LOGV(x, ...) ALOGV("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
 #define ST_LOGD(x, ...) ALOGD("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
@@ -375,7 +377,10 @@ status_t BufferQueue::dequeueBuffer(int *outBuf, sp<Fence>* outFence, bool async
                     ST_LOGE("dequeueBuffer: would block! returning an error instead.");
                     return WOULD_BLOCK;
                 }
-                mDequeueCondition.wait(mMutex);
+                if (mDequeueCondition.waitRelative(mMutex, DEQUEUE_TIMEOUT_VALUE)) {
+                    ST_LOGE("dequeueBuffer: time out and will free all buffer!");
+                    freeAllBuffersLocked();
+                }
             }
         }
 
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index a9dc7b3..ab73060 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -974,7 +974,9 @@ __eglMustCastToProperFunctionPointerType eglGetProcAddress(const char *procname)
             }
 
             if (found) {
+#if defined (__arm__) || defined (__mips__)
                 addr = gExtensionForwarders[slot];
+#endif
                 sGLExtentionMap.add(name, addr);
                 sGLExtentionSlot++;
             }
diff --git a/services/sensorservice/Android.mk b/services/sensorservice/Android.mk
index 683af00..3e6acfc 100644
--- a/services/sensorservice/Android.mk
+++ b/services/sensorservice/Android.mk
@@ -12,7 +12,9 @@ LOCAL_SRC_FILES:= \
     SensorDevice.cpp \
     SensorFusion.cpp \
     SensorInterface.cpp \
-    SensorService.cpp
+    SensorService.cpp \
+    VirtualOrientationSensor.cpp \
+    SecondOrderLowPassFilter.cpp
 
 LOCAL_CFLAGS:= -DLOG_TAG=\"SensorService\"
 
diff --git a/services/sensorservice/SensorService.cpp b/services/sensorservice/SensorService.cpp
index b1ed763..9410d83 100644
--- a/services/sensorservice/SensorService.cpp
+++ b/services/sensorservice/SensorService.cpp
@@ -45,6 +45,7 @@
 #include "GravitySensor.h"
 #include "LinearAccelerationSensor.h"
 #include "OrientationSensor.h"
+#include "VirtualOrientationSensor.h"
 #include "RotationVectorSensor.h"
 #include "SensorFusion.h"
 #include "SensorService.h"
@@ -80,6 +81,8 @@ void SensorService::onFirstRef()
         if (count > 0) {
             ssize_t orientationIndex = -1;
             bool hasGyro = false;
+            bool hasMag = false;
+            bool hasAccel = false;
             uint32_t virtualSensorsNeeds =
                     (1<<SENSOR_TYPE_GRAVITY) |
                     (1<<SENSOR_TYPE_LINEAR_ACCELERATION) |
@@ -96,6 +99,12 @@ void SensorService::onFirstRef()
                     case SENSOR_TYPE_GYROSCOPE_UNCALIBRATED:
                         hasGyro = true;
                         break;
+                    case SENSOR_TYPE_ACCELEROMETER:
+                        hasAccel = true;
+                        break;
+                    case SENSOR_TYPE_MAGNETIC_FIELD:
+                        hasMag = true;
+                        break;
                     case SENSOR_TYPE_GRAVITY:
                     case SENSOR_TYPE_LINEAR_ACCELERATION:
                     case SENSOR_TYPE_ROTATION_VECTOR:
@@ -104,6 +113,14 @@ void SensorService::onFirstRef()
                 }
             }
 
+            if (hasAccel && hasMag && !hasGyro) {
+                // CTS test defines device has to support orientation sensor
+                // if accelerometer sensor and magnetic sensor are available.
+                // However framework does not provide orientation sensor if
+                // no gyro available.
+                // This provide a orientation sensor without fusion support.
+                registerVirtualSensor( new VirtualOrientationSensor(list, count) );
+            }
             // it's safe to instantiate the SensorFusion object here
             // (it wants to be instantiated after h/w sensors have been
             // registered)
@@ -137,7 +154,11 @@ void SensorService::onFirstRef()
                 if (virtualSensorsNeeds & (1<<SENSOR_TYPE_ROTATION_VECTOR)) {
                     // if we are doing our own rotation-vector, also add
                     // the orientation sensor and remove the HAL provided one.
-                    mUserSensorList.replaceAt(aSensor, orientationIndex);
+                    // add orientation sensor if there is not one
+                    if (orientationIndex < 0)
+                        mUserSensorList.add(aSensor);
+                    else
+                        mUserSensorList.replaceAt(aSensor, orientationIndex);
                 }
 
                 // virtual debugging sensors are not added to mUserSensorList
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 3c5c847..839ab69 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -466,12 +466,46 @@ status_t SurfaceFlinger::selectEGLConfig(EGLDisplay display, EGLint nativeVisual
 
     err = selectConfigForAttribute(display, attribs, wantedAttribute,
         wantedAttributeValue, config);
-    if (err == NO_ERROR) {
-        EGLint caveat;
-        if (eglGetConfigAttrib(display, *config, EGL_CONFIG_CAVEAT, &caveat))
-            ALOGW_IF(caveat == EGL_SLOW_CONFIG, "EGL_SLOW_CONFIG selected!");
-    }
+    if (err == NO_ERROR)
+        goto success;
+
+    // If the above failed on the fallback path, there's nothing more we can do
+    if (!renderableType)
+        goto out;
+
+    // Try again without EGL_FRAMEBUFFER_TARGET_ANDROID
+    ALOGW("no suitable EGLConfig found, trying without EGL_FRAMEBUFFER_TARGET_ANDROID");
+    attribs.remove(EGL_FRAMEBUFFER_TARGET_ANDROID);
+    err = selectConfigForAttribute(display, attribs, wantedAttribute, wantedAttributeValue, config);
+    if (err == NO_ERROR)
+        goto success;
+
+    // Try again without EGL_RECORDABLE_ANDROID
+    ALOGW("no suitable EGLConfig found, trying without EGL_RECORDABLE_ANDROID");
+    attribs.remove(EGL_RECORDABLE_ANDROID);
+    err = selectConfigForAttribute(display, attribs, wantedAttribute, wantedAttributeValue, config);
+    if (err == NO_ERROR)
+        goto success;
+
+    // Try again allowing 16-bit color
+    ALOGW("no suitable EGLConfig found, trying with 16-bit color allowed");
+    attribs.remove(EGL_RED_SIZE);
+    attribs.remove(EGL_GREEN_SIZE);
+    attribs.remove(EGL_BLUE_SIZE);
+    err = selectConfigForAttribute(display, attribs, wantedAttribute, wantedAttributeValue, config);
+    if (err == NO_ERROR)
+        goto success;
+
+out:
+    // Failed to find a config
     return err;
+
+success:
+    EGLint caveat;
+    if (eglGetConfigAttrib(display, *config, EGL_CONFIG_CAVEAT, &caveat))
+        ALOGW_IF(caveat == EGL_SLOW_CONFIG, "EGL_SLOW_CONFIG selected!");
+
+    return NO_ERROR;
 }
 
 class DispSyncSource : public VSyncSource, private DispSync::Callback {
@@ -561,6 +595,7 @@ void SurfaceFlinger::init() {
 
     if (err != NO_ERROR) {
         // If ES2 fails, try ES1
+        ALOGW("no suitable EGLConfig found, trying OpenGL ES 1.1");
         err = selectEGLConfig(mEGLDisplay, mHwc->getVisualID(),
                 EGL_OPENGL_ES_BIT, &mEGLConfig);
     }
@@ -3186,7 +3221,7 @@ class GraphicProducerWrapper : public BBinder, public MessageHandler {
             looper->sendMessage(this, Message(MSG_API_CALL));
             barrier.wait();
         }
-        return NO_ERROR;
+        return result;
     }
 
     /*
@@ -3196,7 +3231,8 @@ class GraphicProducerWrapper : public BBinder, public MessageHandler {
     virtual void handleMessage(const Message& message) {
         android_atomic_release_load(&memoryBarrier);
         if (message.what == MSG_API_CALL) {
-            impl->asBinder()->transact(code, data[0], reply);
+            //the transact result needs to be held to let main thread know
+            result = impl->asBinder()->transact(code, data[0], reply);
             barrier.open();
         } else if (message.what == MSG_EXIT) {
             exitRequested = true;
